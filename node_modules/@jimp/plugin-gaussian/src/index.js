import { isNodePattern, throwError } from "@jimp/utils";

/**
 * Applies a true Gaussian blur to the image.
 * This is a very slow operation.
 * @param {number} r - The pixel radius of the blur.
 * @param {function(Error, Jimp)=} cb - A callback for when complete.
 * @returns {Jimp} this for chaining of methods
 */
export default () => ({
  gaussian(r, cb) {
    if (typeof r !== "number") {
      return throwError.call(this, "r must be a number", cb);
    }

    if (r < 1) {
      return throwError.call(this, "r must be greater than 0", cb);
    }

    if (typeof cb !== "function") {
      cb = null;
    }

    const rs = Math.ceil(r * 2.57); // significant radius
    const range = rs * 2 + 1;
    const rr2 = r * r * 2;
    const rr2pi = rr2 * Math.PI;

    const weights = Array.from({ length: range }, (_, i) =>
      Array.from({ length: range }, (_, j) => {
        const dsq = (j - rs) ** 2 + (i - rs) ** 2;
        return Math.exp(-dsq / rr2) / rr2pi;
      })
    );

    const processPixel = (y, x) => {
      let red = 0;
      let green = 0;
      let blue = 0;
      let alpha = 0;
      let wsum = 0;

      for (let iy = 0; iy < range; iy++) {
        for (let ix = 0; ix < range; ix++) {
          const x1 = Math.min(
            this.bitmap.width - 1,
            Math.max(0, ix + x - rs)
          );
          const y1 = Math.min(
            this.bitmap.height - 1,
            Math.max(0, iy + y - rs)
          );
          const weight = weights[iy][ix];
          const idx = (y1 * this.bitmap.width + x1) << 2;

          red += this.bitmap.data[idx] * weight;
          green += this.bitmap.data[idx + 1] * weight;
          blue += this.bitmap.data[idx + 2] * weight;
          alpha += this.bitmap.data[idx + 3] * weight;
          wsum += weight;
        }
      }

      const idx = (y * this.bitmap.width + x) << 2;

      this.bitmap.data[idx] = Math.round(red / wsum);
      this.bitmap.data[idx + 1] = Math.round(green / wsum);
      this.bitmap.data[idx + 2] = Math.round(blue / wsum);
      this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
    };

    const processRow = (y) => {
      for (let x = 0; x < this.bitmap.width; x++) {
        processPixel(y, x);
      }
    };

    const processImage = () => {
      for (let y = 0; y < this.bitmap.height; y++) {
        processRow(y);
      }

      if (cb) {
        cb(null, this);
      }
    };

    if (isNodePattern(cb)) {
      processImage();
    } else {
      const processNextRow = () => {
        const y = requestAnimationFrame(() => {
          processNextRow();
          processRow(y);

          if (y === this.bitmap.height - 1) {
            processImage();
          }
        });
      };

      processNextRow();
    }

    return this;
  },
});
