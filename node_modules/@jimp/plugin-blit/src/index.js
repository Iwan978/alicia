import { throwError, isNodePattern } from "@jimp/utils";

export default () => ({
  /**
   * Blits a source image onto this image
   * @param src The source Jimp instance
   * @param x The x position to blit the image
   * @param y The y position to blit the image
   * @param srcx (optional) The x position from which to crop the source image
   * @param srcy (optional) The y position from which to crop the source image
   * @param srcw (optional) The width to which to crop the source image
   * @param srch (optional) The height to which to crop the source image
   * @param cb (optional) A callback for when complete
   * @returns This for chaining of methods
   */
  blit(
    src: this["constructor"],
    x: number,
    y: number,
    srcx?: number,
    srcy?: number,
    srcw?: number,
    srch?: number,
    cb?: (err: Error | null, img: this["constructor"]) => void
  ): this["constructor"] {
    if (!(src instanceof this.constructor)) {
      throwError.call(this, "The source must be a Jimp image", cb);
    }

    x = Math.round(x);
    y = Math.round(y);
    srcx = Math.round(srcx || 0);
    srcy = Math.round(srcy || 0);
    srcw = Math.round(srcw || src.bitmap.width);
    srch = Math.round(srch || src.bitmap.height);

    const maxWidth = this.bitmap.width;
    const maxHeight = this.bitmap.height;
    const baseImage = this;

    src.scanQuiet(srcx, srcy, srcw, srch, function (sx, sy, idx) {
      const xOffset = x + sx - srcx;
      const yOffset = y + sy - srcy;

      if (
        xOffset >= 0 &&
        yOffset >= 0 &&
        xOffset < maxWidth &&
        yOffset < maxHeight
      ) {
        const dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
        const src = {
          r: this.bitmap.data[idx],
          g: this.bitmap.data[idx + 1],
          b: this.bitmap.data[idx + 2],
          a: this.bitmap.data[idx + 3],
        };

        const dst = {
          r: baseImage.bitmap.data[dstIdx],
          g: baseImage.bitmap.data[dstIdx + 1],
          b: baseImage.bitmap.data[dstIdx + 2],
          a: baseImage.bitmap.data[dstIdx + 3],
        };

        baseImage.bitmap.data[dstIdx] =
          ((src.a * (src.r - dst.r) - dst.r + 255) >> 8) + dst.r;
        baseImage.bitmap.data[dstIdx + 1] =
          ((src.a * (src.g - dst.g) - dst.g + 255) >> 8) + dst.g;
        baseImage.bitmap.data[dstIdx + 2] =
          ((src.a * (src.b - dst.b) - dst.b + 255) >> 8) + dst.b;
        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(
          dst.a + src.a
        );
      }
    });

    if (typeof cb === "function") {
      cb.call(this, null, this);
    }

    return this;
  },
});
