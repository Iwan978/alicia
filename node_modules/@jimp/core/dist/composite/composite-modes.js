"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function composite(operation, src, dst, ops = 1) {
  src.a *= ops;
  const a = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;

  switch (operation) {
    case "srcOver":
      return {
        r: (sra * src.a + dra * dst.a * (1 - src.a)) / a,
        g: (sga * src.a + dga * dst.a * (1 - src.a)) / a,
        b: (sba * src.a + dba * dst.a * (1 - src.a)) / a,
        a
      };
    case "dstOver":
      return {
        r: (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a,
        g: (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a,
        b: (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a,
        a
      };
    case "multiply":
      return {
        r: (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
        g: (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
        b: (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
        a
      };
    case "add":
      return {
        r: (sra + dra) / a,
        g: (sga + dga) / a,
        b: (sba + dba) / a,
        a
      };
    case "screen":
      return {
        r: (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
        g: (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
        b: (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
        a
      };
    case "overlay":
      return {
        r: (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a,
        g: (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a,
        b: (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a,
        a
      };
    case "darken":
      return {
        r: (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
        g: (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
        b: (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
        a
      };
    case "lighten":
      return {
        r: (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
        g: (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
        b: (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
        a
      };
    case "hardLight":
      return {
        r: (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a,
        g: (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a,
        b: (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a,
        a
      };
    case "difference":
      return {
        r: (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a,
        g: (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a,
        b: (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a,
        a
      };
    case "exclusion":
      return {
        r: (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
        g: (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
        b: (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
        a
      };
    default:
      throw new Error("Invalid composite operation");
  }
}

exports.srcOver = (src, dst, ops = 1) => composite("srcOver", src, dst, ops);
exports.dstOver = (src, dst, ops = 1) => composite("dstOver", src, dst, ops);
exports.multiply = (src, dst, ops = 1) => composite("multiply", src, dst, ops);
exports.add = (src, dst, ops = 1) => composite("add", src, dst, ops);
exports.screen = (src, dst, ops = 1) => composite("screen", src, dst, ops);
exports.overlay = (src, dst, ops = 1) => composite("overlay", src, dst, ops);
exports.darken = (src, dst, ops = 1) => composite("darken", src, dst, ops);
exports.lighten = (src, dst, ops = 1) => composite("lighten", src, dst, ops);
exports.hardLight = (src, dst, ops = 1) => composite("hardLight", src, dst, ops);
exports.difference = (src, dst, ops = 1) => composite("difference", src, dst, ops);
exports.exclusion = (src, dst, ops = 1) => composite("exclusion", src, dst, ops);
