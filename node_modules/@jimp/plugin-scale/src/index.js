import { isNodePattern, throwError } from "@jimp/utils";

export default () => ({
  /**
   * Uniformly scales the image by a factor.
   * @param f - the factor to scale the image by
   * @param mode - (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
   * @param cb - (optional) a callback for when complete
   * @returns this for chaining of methods
   */
  scale(f: number, mode?: string, cb?: (err: Error, jimp: Jimp) => void): Jimp {
    if (typeof f !== "number") {
      throw throwError("f must be a number", cb);
    }

    if (f < 0) {
      throw throwError("f must be a positive number", cb);
    }

    const [newMode, newCb] = this.extractCallback(mode, cb);

    const width = this.bitmap.width * f;
    const height = this.bitmap.height * f;
    this.resize(width, height, newMode);

    newCb?.(null, this);

    return this;
  },

  /**
   * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
   * @param w - the width to resize the image to
   * @param h - the height to resize the image to
   * @param mode - (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
   * @param cb - (optional) a callback for when complete
   * @returns this for chaining of methods
   */
  scaleToFit(w: number, h: number, mode?: string, cb?: (err: Error, jimp: Jimp) => void): Jimp {
    const [newMode, newCb] = this.extractCallback(mode, cb);

    const factor =
      w / h > this.bitmap.width / this.bitmap.height
        ? h / this.bitmap.height
        : w / this.bitmap.width;

    this.scale(factor, newMode);

    newCb?.(null, this);

    return this;
  },

  private extractCallback(mode?: string, cb?: (err: Error, jimp: Jimp) => void): [string | undefined, (err: Error, jimp: Jimp) => void] {
    if (typeof cb === "function" && typeof mode === "undefined") {
      return [undefined, cb];
    }

    return [mode, cb];
  }
});
