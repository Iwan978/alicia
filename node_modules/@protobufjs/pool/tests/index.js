const tape = require("tape");
const { createPool } = require("..");

const testPool = (label, poolFunc) => {
  const testCases = [
    { size: 0, length: 0 },
    { size: 1, length: 1 },
    { size: 4097, length: 4097 },
    { size: 4096, length: 4096 },
    { size: 4096, length: 4096 },
  ];

  tape.test(label, (t) => {
    t.plan(testCases.length * 3);

    const bufferPool = poolFunc((size) => new Uint8Array(size), Uint8Array.prototype.subarray);

    testCases.forEach(({ size, length }) => {
      const buffer1 = bufferPool(size);
      t.equal(buffer1.length, length, `should allocate a buffer of size ${length}`);

      const buffer2 = bufferPool(size);
      t.notEqual(buffer2.buffer, buffer1.buffer, `should not reference the same backing buffer if previous buffer had size 0`);
      t.equal(buffer2.byteOffset, 0, `should allocate at byteOffset 0 when using a new slab`);

      const buffer3 = bufferPool(size);
      t.deepEqual(buffer3, buffer2, `should reference the same backing buffer when allocating a buffer smaller or equal than half the backing buffer's size`);

      if (size === 4097) {
        t.notEqual(buffer3.buffer, buffer2.buffer, `should not reference the same backing buffer when allocating a buffer larger than half the backing buffer's size`);
      } else {
        t.equal(buffer3.buffer, buffer2.buffer, `should reference the same backing buffer when allocating a buffer smaller or equal than half the backing buffer's size`);
      }
    });

    t.end();
  });
};

testPool("Pool with Uint8Array", (size) => createPool((size) => new Uint8Array(size), Uint8Array.prototype.subarray));
