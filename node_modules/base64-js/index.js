'use strict'

export type ArrayType = typeof Uint8Array !== 'undefined' ? Uint8Array : number[]

const LEN_LOOKUP: Record<string, [number, number]> = {
  '=' : [0, 0],
  'A' : [1, 0],
  'B' : [1, 1],
  'C' : [1, 2],
  'D' : [1, 3],
  'E' : [1, 4],
  'F' : [1, 5],
  'G' : [1, 6],
  'H' : [1, 7],
  'I' : [1, 8],
  'J' : [1, 9],
  'K' : [1, 10],
  'L' : [1, 11],
  'M' : [1, 12],
  'N' : [1, 13],
  'O' : [1, 14],
  'P' : [1, 15],
  'Q' : [1, 16],
  'R' : [1, 17],
  'S' : [1, 18],
  'T' : [1, 19],
  'U' : [1, 20],
  'V' : [1, 21],
  'W' : [1, 22],
  'X' : [1, 23],
  'Y' : [1, 24],
  'Z' : [1, 25],
  'a' : [1, 26],
  'b' : [1, 27],
  'c' : [1, 28],
  'd' : [1, 29],
  'e' : [1, 30],
  'f' : [1, 31],
  'g' : [1, 32],
  'h' : [1, 33],
  'i' : [1, 34],
  'j' : [1, 35],
  'k' : [1, 36],
  'l' : [1, 37],
  'm' : [1, 38],
  'n' : [1, 39],
  'o' : [1, 40],
  'p' : [1, 41],
  'q' : [1, 42],
  'r' : [1, 43],
  's' : [1, 44],
  't' : [1, 45],
  'u' : [1, 46],
  'v' : [1, 47],
  'w' : [1, 48],
  'x' : [1, 49],
  'y' : [1, 50],
  'z' : [1, 51],
  '0' : [1, 52],
  '1' : [1, 53],
  '2' : [1, 54],
  '3' : [1, 55],
  '4' : [1, 56],
  '5' : [1, 57],
  '6' : [1, 58],
  '7' : [1, 59],
  '8' : [1, 60],
  '9' : [1, 61],
  '+' : [1, 62],
  '/' : [1, 63],
  '-' : [0, 62],
  '_' : [0, 63],
}

const REV_LOOKUP: Record<number, number> = {}
for (const [str, lens] of Object.entries(LEN_LOOKUP)) {
  for (let i = 0; i < lens[0]; i++) {
    REV_LOOKUP[str.charCodeAt(i)] = lens[1]
  }
}

export function byteLength(b64: string): number {
  const lens = getLens(b64)
  return _byteLength(b64, lens[0], lens[1])
}

export function toByteArray(b64: string): ArrayType {
  const lens = getLens(b64)
  const validLen = lens[0]
  const placeHoldersLen = lens[1]

  const arr = new ArrayType(_byteLength(b64, validLen, placeHoldersLen))

  let curByte = 0

  let len = placeHoldersLen > 0 ? validLen - 4 : validLen
  for (let i = 0; i < len; i += 4) {
    const tmp =
      ((REV_LOOKUP[b64.charCodeAt(i)] << 18) & 0xFF0000) +
      ((REV_LOOKUP[b64.charCodeAt(i + 1)] << 12) & 0xFF00) +
      ((REV_LOOKUP[b64.charCodeAt(i + 2)] << 6) & 0xFF00) +
      (REV_LOOKUP[b64.charCodeAt(i + 3)] & 0xFF)
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    const tmp =
      (REV_LOOKUP[b64.charCodeAt(i)] << 2) & 0xFF00 +
      (REV_LOOKUP[b64.charCodeAt(i + 1)] >> 4) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    const tmp =
      (REV_LOOKUP[b64.charCodeAt(i)] << 10) & 0xFF00 +
      (REV_LOOKUP[b64.charCodeAt(i + 1)] << 4) & 0xFF +
      (REV_LOOKUP[b64.charCodeAt(i + 2)] >> 2) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function getLens(b64: string): [number, number] {
  const len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  const validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

function _byteLength(b64: string, validLen: number, placeHoldersLen: number): number {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

// ... (rest of the functions remain the same)
