'use strict';

const Assert = require('./assert');

const internals = {
  isCircular: (value, seen = new WeakSet()) => {
    if (seen.has(value)) {
      return true;
    }
    seen.add(value);
    if (Array.isArray(value)) {
      for (const item of value) {
        if (internals.isCircular(item, seen)) {
          return true;
        }
      }
    } else if (typeof value === 'object') {
      for (const key of Object.keys(value)) {
        if (internals.isCircular(value[key], seen)) {
          return true;
        }
      }
    }
    return false;
  },
  clone: (value, options = {}) => {
    const { symbols = true, dereferenceCheck = false, deepClone = false } = options;
    if (value === null || typeof value !== 'object') {
      return value;
    }
    if (dereferenceCheck && internals.isCircular(value)) {
      throw new Error('Circular reference detected');
    }
    if (Array.isArray(value)) {
      return value.map(item => internals.clone(item, options));
    }
    const clonedValue = {};
    for (const key of Object.keys(value)) {
      if (symbols && typeof key === 'symbol') {
        continue;
      }
      clonedValue[key] = internals.clone(value[key], options);
    }
    if (deepClone) {
      return internals.merge(clonedValue, value, { nullOverride: true, mergeArrays: true, symbols: options.symbols });
    }
    return clonedValue;
  },
  merge: (target, source, options = {}) => {
    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
    Assert(options === null || typeof options === 'object', 'Invalid options value: must be null, undefined, or an object');

    if (!source) {
      return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true, ignoreKeys: [] }, options);

    if (Array.isArray(source)) {
      Assert(Array.isArray(target), 'Cannot merge array onto an object');
      if (!options.mergeArrays) {
        target.length = 0;                                                          // Must not change target assignment
      }

      for (let i = 0; i < source.length; ++i) {
        target.push(internals.clone(source[i], { symbols: options.symbols }));
      }

      return target;
    }

    const keys = Object.keys(source).filter(key => !options.ignoreKeys.includes(key) && (key !== '__proto__' || typeof source !== 'object'));
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      const value = source[key];
      if (value && typeof value === 'object') {
        if (target[key] === value) {
          continue;                                           // Can occur for shallow merges
        }

        if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value)) {
          target[key] = internals.clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }

    return target;
  }
};

module.exports = internals.merge;
