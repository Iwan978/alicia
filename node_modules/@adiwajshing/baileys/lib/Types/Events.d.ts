import type { Boom } from '@hapi/boom';
import { proto } from '../../WAProto';
import { AuthenticationCreds } from './Auth';
import { WACallEvent } from './Call';
import { Chat, ChatUpdate, PresenceData } from './Chat';
import { Contact } from './Contact';
import { GroupMetadata, ParticipantAction } from './GroupMetadata';
import { Label } from './Label';
import { LabelAssociation } from './LabelAssociation';
import { MessageUpsertType, MessageUserReceiptUpdate, WAMessage, WAMessageKey, WAMessageUpdate } from './Message';
import { ConnectionState } from './State';

export type BaileysEventMap = {
  'connection.update': Partial<ConnectionState>;
  'creds.update': Partial<AuthenticationCreds>;
  'messaging-history.set': {
    chats: Chat[];
    contacts: Contact[];
    messages: WAMessage[];
    isLatest: boolean;
  };
  'chats.upsert': Chat[];
  'chats.update': ChatUpdate[];
  'chats.delete': string[];
  'presence.update': {
    id: string;
    presences: {
      [participant: string]: PresenceData;
    };
  };
  'contacts.upsert': Contact[];
  'contacts.update': Partial<Contact>[];
  'messages.delete': {
    keys: WAMessageKey[];
  } | {
    jid: string;
    all: true;
  };
  'messages.update': WAMessageUpdate[];
  'messages.media-update': {
    key: WAMessageKey;
    media?: {
      ciphertext: Uint8Array;
      iv: Uint8Array;
    };
    error?: Boom;
  }[];
  'messages.upsert': {
    messages: WAMessage[];
    type: MessageUpsertType;
  };
  'messages.reaction': {
    key: WAMessageKey;
    reaction: proto.IReaction;
  }[];
  'message-receipt.update': MessageUserReceiptUpdate[];
  'groups.upsert': GroupMetadata[];
  'groups.update': Partial<GroupMetadata>[];
  'group-participants.update': {
    id: string;
    participants: string[];
    action: ParticipantAction;
  };
  'blocklist.set': {
    blocklist: string[];
  };
  'blocklist.update': {
    blocklist: string[];
    type: 'add' | 'remove';
  };
  'call': WACallEvent[];
  'labels.edit': Label;
  'labels.association': {
    association: LabelAssociation;
    type: 'add' | 'remove';
  };
};

export type BufferedEventData = {
  historySets: {
    chats: {
      [jid: string]: Chat;
    };
    contacts: {
      [jid: string]: Contact;
    };
    messages: {
      [uqId: string]: WAMessage;
    };
    empty: boolean;
    isLatest: boolean;
  };
  chatUpserts: {
    [jid: string]: Chat;
  };
  chatUpdates: {
    [jid: string]: ChatUpdate;
  };
  chatDeletes: Set<string>;
  contactUpserts: {
    [jid: string]: Contact;
  };
  contactUpdates: {
    [jid: string]: Partial<Contact>;
  };
  messageUpserts: {
    [key: string]: {
      type: MessageUpsertType;
      message: WAMessage;
    };
  };
  messageUpdates: {
    [key: string]: WAMessageUpdate;
  };
  messageDeletes: {
    [key: string]: WAMessageKey;
  };
  messageReactions: {
    [key: string]: {
      key: WAMessageKey;
      reactions: proto.IReaction[];
    };
  };
  messageReceipts: {
    [key: string]: {
      key: WAMessageKey;
      userReceipt: proto.IUserReceipt[];
    };
  };
  groupUpdates: {
    [jid: string]: Partial<GroupMetadata>;
  };
};

export type BaileysEvent = keyof BaileysEventMap;

export interface BaileysEventEmitter {
  on<T extends keyof BaileysEventMap>(event: T, listener: (arg: BaileysEventMap[T]) => void): void;
  off<T extends keyof BaileysEventMap>(event: T, listener: (arg: BaileysEventMap[T]) => void): void;
  removeAllListeners<T extends keyof BaileysEventMap>(event: T): void;
  emit<T extends keyof BaileysEventMap>(event: T, arg: BaileysEventMap[T]): boolean;
}

// Type guard to check if the given event is a 'messages.delete' event
function isMessagesDeleteEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { keys: WAMessageKey[] } | { jid: string, all: true } {
  return event.hasOwnProperty('keys') || (event.hasOwnProperty('jid') && event.hasOwnProperty('all'));
}

// Type guard to check if the given event is a 'messages.update' event
function isMessagesUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is WAMessageUpdate[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('messages') && e.hasOwnProperty('type'));
}

// Type guard to check if the given event is a 'messages.media-update' event
function isMessagesMediaUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { key: WAMessageKey, media?: { ciphertext: Uint8Array, iv: Uint8Array }, error?: Boom }[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('key') && (!e.hasOwnProperty('media') || (e.media && e.media.hasOwnProperty('ciphertext') && e.media.hasOwnProperty('iv'))) && (!e.hasOwnProperty('error') || e.error instanceof Boom));
}

// Type guard to check if the given event is a 'messages.upsert' event
function isMessagesUpsertEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { messages: WAMessage[], type: MessageUpsertType } {
  return event.hasOwnProperty('messages') && event.hasOwnProperty('type') && Array.isArray(event.messages);
}

// Type guard to check if the given event is a 'messages.reaction' event
function isMessagesReactionEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { key: WAMessageKey, reaction: proto.IReaction }[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('key') && e.key.hasOwnProperty('remote') && e.key.hasOwnProperty('id') && e.hasOwnProperty('reaction') && typeof e.reaction === 'object');
}

// Type guard to check if the given event is a 'message-receipt.update' event
function isMessageReceiptUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is MessageUserReceiptUpdate[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('receipts') && Array.isArray(e.receipts));
}

// Type guard to check if the given event is a 'groups.upsert' event
function isGroupsUpsertEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is GroupMetadata[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('id') && e.id.length > 0 && e.hasOwnProperty('subject') && typeof e.subject === 'string');
}

// Type guard to check if the given event is a 'groups.update' event
function isGroupsUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is Partial<GroupMetadata>[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('id') && e.id.length > 0);
}

// Type guard to check if the given event is a 'group-participants.update' event
function isGroupParticipantsUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { id: string, participants: string[], action: ParticipantAction } {
  return event.hasOwnProperty('id') && event.id.length > 0 && event.hasOwnProperty('participants') && Array.isArray(event.participants) && event.participants.every(p => p.length > 0) && event.hasOwnProperty('action') && typeof event.action === 'string';
}

// Type guard to check if the given event is a 'blocklist.set' event
function isBlocklistSetEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { blocklist: string[] } {
  return event.hasOwnProperty('blocklist') && Array.isArray(event.blocklist);
}

// Type guard to check if the given event is a 'blocklist.update' event
function isBlocklistUpdateEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { blocklist: string[], type: 'add' | 'remove' } {
  return event.hasOwnProperty('blocklist') && Array.isArray(event.blocklist) && event.hasOwnProperty('type') && typeof event.type === 'string';
}

// Type guard to check if the given event is a 'call' event
function isCallEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is WACallEvent[] {
  return Array.isArray(event) && event.every(e => e.hasOwnProperty('call') && e.call.hasOwnProperty('id') && typeof e.call.id === 'string');
}

// Type guard to check if the given event is a 'labels.edit' event
function isLabelsEditEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is Label {
  return event.hasOwnProperty('id') && typeof event.id === 'string' && event.hasOwnProperty('color') && typeof event.color === 'string';
}

// Type guard to check if the given event is a 'labels.association' event
function isLabelsAssociationEvent(event: BaileysEventMap[keyof BaileysEventMap]): event is { association: LabelAssociation, type: 'add' | 'remove' } {
  return event.hasOwnProperty('association') && event.association.hasOwnProperty('id') && typeof event.association.id === 'string' && event.hasOwnProperty('type') && typeof event.type === 'string';
}
