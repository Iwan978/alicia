import { Logger } from 'pino';
import { BaileysEventEmitter, BaileysEventMap } from '../Types';

type BaileysEventData = Partial<BaileysEventMap>;

type ProcessHandler = (events: BaileysEventData) => void | Promise<void>;

type BufferedFunction<A extends any[], T> = (...args: A) => Promise<T>;

type BaileysBufferableEventEmitter = BaileysEventEmitter & {
    /** Use to process events in a batch */
    process: (handler: ProcessHandler) => () => void;
    /**
     * starts buffering events, call flush() to release them
     * */
    buffer(): void;
    /** buffers all events till the promise completes */
    createBufferedFunction<A extends any[], T>(work: (...args: A) => Promise<T>): BufferedFunction<A, T>;
    /**
     * flushes all buffered events
     * @param force if true, will flush all data regardless of any pending buffers
     * @returns returns true if the flush actually happened, otherwise false
     */
    flush(force?: boolean): boolean;
    /** is there an ongoing buffer */
    isBuffering(): boolean;
};

/**
 * The event buffer logically consolidates different events into a single event
 * making the data processing more efficient.
 * @param ev the baileys event emitter
 */
export declare const makeEventBuffer = (logger: Logger): BaileysBufferableEventEmitter => {
    let isProcessing = false;
    let isBuffering = false;
    let eventData: BaileysEventData = {};

    const process = (handler: ProcessHandler): (() => void) => {
        if (isProcessing) {
            throw new Error('Event buffer is already processing events');
        }
        isProcessing = true;
        const handlerWrapper = (): void => {
            handler(eventData);
            eventData = {};
            isProcessing = false;
        };
        return handlerWrapper;
    };

    const buffer = (): void => {
        if (isBuffering) {
            throw new Error('Event buffer is already buffering events');
        }
        isBuffering = true;
    };

    const createBufferedFunction = <A extends any[], T>(work: (...args: A) => Promise<T>): BufferedFunction<A, T> => {
        return async (...args: A): Promise<T> => {
            buffer();
            const result = await work(...args);
            flush();
            return result;
        };
    };

    const flush = (force?: boolean): boolean => {
        if (isBuffering && !force) {
            return false;
        }
        isBuffering = false;
        logger.debug('Flushing event buffer:', eventData);
        process((events) => {
            // Handle the events here
        })(eventData);
        eventData = {};
        return true;
    };

    const isBuffering = (): boolean => isBuffering;

    return {
        process,
        buffer,
        createBufferedFunction,
        flush,
        isBuffering,
    };
};

export {};
