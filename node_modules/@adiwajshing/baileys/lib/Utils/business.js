"use strict";
import { Boom } from "@hapi/boom";
import { createHash } from "crypto";
import WABinary from "../WABinary";
import {
  getStream,
  toReadable,
  getUrlFromDirectPath,
} from "./messages-media";

export type Product = {
  id: string;
  imageUrls: {
    requested: string;
    original: string;
  };
  reviewStatus: {
    whatsapp: string;
  };
  availability: string;
  name: string;
  retailerId: string;
  url: string;
  description: string;
  price: number;
  currency: string;
  isHidden: boolean;
  images?: { url: string }[];
};

export type Collection = {
  id: string;
  name: string;
  products: Product[];
  status: {
    status: string;
    canAppeal: boolean;
  };
};

export type OrderDetails = {
  price: {
    total: number;
    currency: string;
  };
  products: {
    id: string;
    name: string;
    imageUrl: string;
    price: number;
    currency: string;
    quantity: number;
  }[];
};

export type Catalog = {
  products: Product[];
  nextPageCursor?: string;
};

export type Collections = {
  collections: Collection[];
};

export type OrderDetailsNode = {
  order: {
    price: {
      total: string;
      currency: string;
    };
    products: {
      id: string;
      name: string;
      image: {
        url: string;
      };
      price: string;
      currency: string;
      quantity: string;
    }[];
  };
};

export type CollectionNode = {
  id: string;
  name: string;
  product: {
    id: string;
    name: string;
    image: {
      url: string;
    };
    price: string;
    currency: string;
  }[];
};

export type ProductNode = {
  id: string;
  name: string;
  description?: string;
  retailer_id?: string;
  media: {
    image: {
      url: string;
    }[];
  };
  price: string;
  currency: string;
  is_hidden?: string;
  compliance_info?: {
    country_code_origin: string;
  };
};

export function parseCatalogNode(node: WABinary.BinaryNode): Catalog {
  const catalogNode = WABinary.getBinaryNodeChild(node, "product_catalog");
  const products = WABinary.getBinaryNodeChildren(catalogNode, "product")
    .map(parseProductNode);
  const paging = WABinary.getBinaryNodeChild(catalogNode, "paging");
  return {
    products,
    nextPageCursor: paging
      ? WABinary.getBinaryNodeChildString(paging, "after")
      : undefined,
  };
}

export function parseCollectionsNode(node: WABinary.BinaryNode): Collections {
  const collectionsNode = WABinary.getBinaryNodeChild(node, "collections");
  const collections = WABinary.getBinaryNodeChildren(collectionsNode, "collection")
    .map(parseCollectionNode);
  return {
    collections,
  };
}

export function parseCollectionNode(node: WABinary.BinaryNode): Collection {
  const id = WABinary.getBinaryNodeChildString(node, "id");
  const name = WABinary.getBinaryNodeChildString(node, "name");
  const products = WABinary.getBinaryNodeChildren(node, "product")
    .map(parseProductNode);
  const statusNode = WABinary.getBinaryNodeChild(node, "status_info");
  return {
    id,
    name,
    products,
    status: {
      status: WABinary.getBinaryNodeChildString(statusNode, "status"),
      canAppeal: WABinary.getBinaryNodeChildString(statusNode, "can_appeal") === "true",
    },
  };
}

export function parseOrderDetailsNode(node: OrderDetailsNode): OrderDetails {
  const orderNode = node.order;
  const products = orderNode.products.map((product) => ({
    id: product.id,
    name: product.name,
    imageUrl: product.image.url,
    price: parseFloat(product.price),
    currency: product.currency,
    quantity: parseFloat(product.quantity),
  }));
  const priceNode = orderNode.price;
  return {
    price: {
      total: parseFloat(priceNode.total),
      currency: priceNode.currency,
    },
    products,
  };
}

export function toProductNode(
  productId: string,
  product: Omit<Product, "images">
): ProductNode {
  const content: ProductNode["content"] = [];
  if (productId) {
    content.push({
      tag: "id",
      attrs: {},
      content: Buffer.from(productId),
    });
  }
  if (product.name) {
    content.push({
      tag: "name",
      attrs: {},
      content: Buffer.from(product.name),
    });
  }
  if (product.description) {
    content.push({
      tag: "description",
      attrs: {},
      content: Buffer.from(product.description),
    });
  }
  if (product.retailerId) {
    content.push({
      tag: "retailer_id",
      attrs: {},
      content: Buffer.from(product.retailerId),
    });
  }
  if (product.images) {
    content.push({
      tag: "media",
      attrs: {},
      content: product.images.map((img) => ({
        tag: "image",
        attrs: {},
        content: [
          {
            tag: "url",
            attrs: {},
            content: Buffer.from(img.url.toString()),
          },
        ],
      })),
    });
  }
  if (product.price) {
    content.push({
      tag: "price",
      attrs: {},
      content: Buffer.from(product.price.toString()),
    });
  }
  if (product.currency) {
    content.push({
      tag: "currency",
      attrs: {},
      content: Buffer.from(product.currency),
    });
  }
  if (product.originCountryCode) {
    if (typeof product.originCountryCode === "undefined") {
      content.push({
        tag: "compliance_info",
        attrs: {
          compliance_category: "COUNTRY_ORIGIN_EXEMPT",
        },
        content: [],
      });
    } else {
      content.push({
        tag: "compliance_info",
        attrs: {},
        content: [
          {
            tag: "country_code_origin",
            attrs: {},
            content: Buffer.from(product.originCountryCode),
          },
        ],
      });
    }
  }
  if (typeof product.isHidden !== "undefined") {
    content.push({
      tag: "is_hidden",
      attrs: {},
      content: Buffer.from(product.isHidden.toString()),
    });
  }
  return {
    tag: "product",
    attrs: {
      is_hidden: product.isHidden?.toString(),
    },
    content,
  };
}

export function parseProductNode(productNode: ProductNode): Product {
  const isHidden = productNode.attrs.is_hidden === "true";
  const id = WABinary.getBinaryNodeChildString(productNode, "id");
  const mediaNode = WABinary.getBinaryNodeChild(productNode, "media");
  const statusInfoNode = WABinary.getBinaryNodeChild(productNode, "status_info");
  const product = {
    id,
    imageUrls: parseImageUrls(mediaNode),
    reviewStatus: {
      whatsapp: WABinary.getBinaryNodeChildString(statusInfoNode, "status"),
    },
    availability: "in stock",
    name: WABinary.getBinaryNodeChildString(productNode, "name"),
    retailerId: WABinary.getBinaryNodeChildString(productNode, "retailer_id"),
    url: WABinary.getBinaryNodeChildString(productNode, "url"),
    description: WABinary.getBinaryNodeChildString(productNode, "description"),
    price: parseFloat(WABinary.getBinaryNodeChildString(productNode, "price")),
    currency: WABinary.getBinaryNodeChildString(productNode, "currency"),
    isHidden,
  };
  if (productNode.compliance_info) {
    product.originCountryCode = WABinary.getBinaryNodeChildString(
      productNode.compliance_info,
      "country_code_origin"
    );
  }
  return product;
}

/**
 * Uploads images not already uploaded to WA's servers
 */
export async function uploadingNecessaryImagesOfProduct(
  product: Product,
  waUploadToServer: (
    stream: NodeJS.ReadableStream,
    options: {
      mediaType: string;
      fileEncSha256B64: string;
      timeoutMs: number;
    }
  ) => Promise<{ directPath: string }>,
  timeoutMs = 30000
): Promise<Product> {
  if (!product.images) {
    return product;
  }
  const imagesToUpload = product.images.filter(
    (img) => !img.url.toString().includes(".whatsapp.net")
  );
  if (imagesToUpload.length === 0) {
    return product;
  }
  const results = await Promise.all(
    imagesToUpload.map(async (img) => {
      const { stream } = await getStream(img);
      const hasher = createHash("sha256");
      const contentBlocks: Buffer[] = [];
      for await (const block of stream) {
        hasher.update(block);
        contentBlocks.push(block);
      }
      const sha = hasher.digest("base64");
      const { directPath } = await waUploadToServer(
        toReadable(Buffer.concat(contentBlocks)),
        {
          mediaType: "product-catalog-image",
          fileEncSha256B64: sha,
          timeoutMs,
        }
      );
      return {
        url: getUrlFromDirectPath(directPath),
      };
    })
  );
  return {
    ...product,
    images: product.images.map((img, i) =>
      imagesToUpload.includes(img) ? results[i] : img
    ),
  };
}

function parseImageUrls(mediaNode: WABinary.BinaryNode) {
  const imgNode = WABinary.getBinaryNodeChild(mediaNode, "image");
  return {
    requested: WABinary.getBinaryNodeChildString(imgNode, "request_image_url"),
    original: WABinary.getBinaryNodeChildString(imgNode, "original_image_url"),
  };
}

function parseStatusInfo(mediaNode: WABinary.BinaryNode) {
  const node = WABinary.getBinaryNodeChild(mediaNode, "status_info");
  return {
    status: WABinary.getBinaryNodeChildString(node, "status"),
    canAppeal: WABinary.getBinaryNodeChildString(node, "can_appeal") === "true",
  };
}
