/// <reference types="node" />
import { Boom } from '@hapi/boom';
import { AxiosRequestConfig } from 'axios';
import type { Logger } from 'pino';
import { Readable, Transform } from 'stream';
import { URL } from 'url';
import { proto } from '../../WAProto';
import {
  DownloadableMessage,
  MediaConnInfo,
  MediaDecryptionKeyInfo,
  MediaType,
  SocketConfig,
  WAMediaUpload,
  WAMediaUploadFunction,
  WAMessageContent,
} from '../Types';
import { BinaryNode } from '../WABinary';

const hkdfInfoKey = (type: MediaType): string => `content.${type}`;

const getMediaKeys = (
  buffer: Uint8Array | string | null | undefined,
  mediaType: MediaType
): MediaDecryptionKeyInfo => {
  // implementation here
};

const extractImageThumb = async (
  bufferOrFilePath: Readable | Buffer | string,
  width?: number
): Promise<{ buffer: Buffer; original: { width?: number; height?: number } }> => {
  // implementation here
};

const encodeBase64EncodedStringForUpload = (b64: string): string => {
  // implementation here
};

const generateProfilePicture = async (
  mediaUpload: WAMediaUpload
): Promise<{ img: Buffer }> => {
  // implementation here
};

const mediaMessageSHA256B64 = (message: WAMessageContent): string | null | undefined => {
  // implementation here
};

const getAudioDuration = async (
  buffer: Buffer | string | Readable
): Promise<number | undefined> => {
  // implementation here
};

const getAudioWaveform = async (
  buffer: Buffer | string | Readable,
  logger?: Logger
): Promise<Uint8Array | undefined> => {
  // implementation here
};

const toReadable = (buffer: Buffer): Readable => {
  // implementation here
};

const toBuffer = async (stream: Readable): Promise<Buffer> => {
  // implementation here
};

const getStream = async (
  item: WAMediaUpload,
  opts?: AxiosRequestConfig
): Promise<
  | {
      readonly stream: Readable;
      readonly type: 'buffer';
    }
  | {
      readonly stream: Readable;
      readonly type: 'readable';
    }
  | {
      readonly stream: Readable;
      readonly type: 'remote';
    }
  | {
      readonly stream: Readable;
      readonly type: 'file';
    }
> => {
  // implementation here
};

const generateThumbnail = async (
  file: string,
  mediaType: 'video' | 'image',
  options: {
    logger?: Logger;
  }
): Promise<{
  thumbnail: string | undefined;
  originalImageDimensions: {
    width: number;
    height: number;
  } | undefined;
}> => {
  // implementation here
};

const getHttpStream = async (
  url: string | URL,
  options?: AxiosRequestConfig & {
    isStream?: true;
  }
): Promise<Readable> => {
  // implementation here
};

type EncryptedStreamOptions = {
  saveOriginalFileIfRequired?: boolean;
  logger?: Logger;
  opts?: AxiosRequestConfig;
};

const encryptedStream = async (
  media: WAMediaUpload,
  mediaType: MediaType,
  { logger, saveOriginalFileIfRequired, opts }: EncryptedStreamOptions
): Promise<{
    mediaKey: Buffer;
    encWriteStream: Readable;
    bodyPath: string | undefined;
    mac: Buffer;
    fileEncSha256: Buffer;
    fileSha256: Buffer;
    fileLength: number;
    didSaveToTmpPath: boolean;
  }> => {
  // implementation here
};

type MediaDownloadOptions = {
  startByte?: number;
  endByte?: number;
  options?: AxiosRequestConfig<any>;
};

const getUrlFromDirectPath = (directPath: string): string => {
  // implementation here
};

const downloadContentFromMessage = async (
  { mediaKey, directPath, url }: DownloadableMessage,
  type: MediaType,
  opts?: MediaDownloadOptions
): Promise<Transform> => {
  // implementation here
};

/**
 * Decrypts and downloads an AES256-CBC encrypted file given the keys.
 * Assumes the SHA256 of the plaintext is appended to the end of the ciphertext
 */
const downloadEncryptedContent = async (
  downloadUrl: string,
  { cipherKey, iv }: MediaDecryptionKeyInfo,
  { startByte, endByte, options }: MediaDownloadOptions = {}
): Promise<Transform> => {
  // implementation here
};

const extensionForMediaMessage = (message: WAMessageContent): string => {
  // implementation here
};

const getWAUploadToServer = (
  {
    customUploadHosts,
    fetchAgent,
    logger,
    options,
  }: SocketConfig,
  refreshMediaConn: (force: boolean) => Promise<MediaConnInfo>
): WAMediaUploadFunction => {
  // implementation here
};

const encryptMediaRetryRequest = (
  key: proto.IMessageKey,
  mediaKey: Buffer | Uint8Array,
  meId: string
): BinaryNode => {
  // implementation here
};

const decodeMediaRetryNode = (node: BinaryNode): {
  key: proto.IMessageKey;
  media?: {
    ciphertext: Uint8Array;
    iv: Uint8Array;
  } | undefined;
  error?: Boom<any> | undefined;
} => {
  // implementation here
};

const decryptMediaRetryData = (
  { ciphertext, iv }: {
    ciphertext: Uint8Array;
    iv: Uint8Array;
  },
  mediaKey: Uint8Array,
  msgId: string
): proto.MediaRetryNotification => {
  // implementation here
};

const getStatusCodeForMediaRetry = (code: number): any => {
  // implementation here
};

export {
  hkdfInfoKey,
  getMediaKeys,
  extractImageThumb,
  encodeBase64EncodedStringForUpload,
  generateProfilePicture,
  mediaMessageSHA256B64,
  getAudioDuration,
  getAudioWaveform,
  toReadable,
  toBuffer,
  getStream,
  generateThumbnail,
  getHttpStream,
  encryptedStream,
  downloadContentFromMessage,
  downloadEncryptedContent,
  extensionForMediaMessage,
  getWAUploadToServer,
  encryptMediaRetryRequest,
  decodeMediaRetryNode,
  decryptMediaRetryData,
  getStatusCodeForMediaRetry,
};
