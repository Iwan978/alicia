export type PaginationMode = 'before' | 'after';

export type Comparable<ObjectType, KeyType> = {
  key: (v: ObjectType) => KeyType;
  compare: (a: KeyType, b: KeyType) => number;
};

export type Identifiable<T> = (v: T) => string;

export interface IKeyedDB<T, K = string> {
  length: number;
  first: T;
  last: T;
  getById: (id: K) => T | undefined;
  toJSON(): any;
  insertMany(...values: T[]): void;
  deleteOne(value: T): void;
}

// Example usage of IKeyedDB
class KeyedDB<T> implements IKeyedDB<T> {
  private data: Map<string, T>;

  constructor(initialData: T[] = []) {
    this.data = new Map(initialData.map((item) => [this.getId(item), item]));
    this.length = initialData.length;
  }

  private getId(value: T): string {
    return (typeof this.getIdForType === 'function' && this.getIdForType(value)) || (value as any).id || '';
  }

  public length: number;

  public first: T | undefined;
  public last: T | undefined;

  public getById(id: K): T | undefined {
    return this.data.get(id);
  }

  public toJSON(): any {
    return Array.from(this.data.values());
  }

  public insertMany(...values: T[]): void {
    const ids = values.map((value) => this.getId(value));
    if (new Set(ids).size !== ids.length) {
      throw new Error('Duplicate keys are not allowed');
    }
    values.forEach((value) => {
      this.data.set(this.getId(value), value);
    });
    this.length += values.length;
    this.first = values[0];
    this.last = values[values.length - 1];
  }

  public deleteOne(value: T): void {
    const id = this.getId(value);
    if (!id) {
      throw new Error('Value has no valid id');
    }
    this.data.delete(id);
    this.length--;
    if (value === this.first) {
      this.first = this.data.values().next().value;
    }
    if (value === this.last) {
      this.last = this.data.values().prev().value;
    }
  }
}
