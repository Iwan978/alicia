"use strict";
import BinarySearch from "./BinarySearch";

class Key<T> {
  constructor(private key: (value: T) => string) {}

  key(value: T): string {
    return this.key(value);
  }

  compare(a: string, b: string): number {
    return a.localeCompare(b);
  }
}

class KeyedDB<T> {
  private key: Key<T>;
  private idGetter: (value: T) => string;
  private dict: { [id: string]: T };
  private array: T[];

  constructor(key: Key<T>, idGetter?: (value: T) => string) {
    this.key = key;
    this.idGetter = idGetter || ((v) => this.key.key(v).toString());
    this.dict = {};
    this.array = [];
  }

  get length(): number {
    return this.array.length;
  }

  get first(): T {
    return this.array[0];
  }

  get last(): T {
    return this.array[this.array.length - 1];
  }

  toJSON(): T[] {
    return this.array;
  }

  insert(...values: T[]): void {
    values.forEach((v) => this._insertSingle(v));
  }

  upsert(...values: T[]): T[] {
    const updates: T[] = [];
    values.forEach((v) => {
      if (!v) return;
      const deleted = this.deleteById(this.idGetter(v), false);
      this._insertSingle(v);
      deleted && updates.push(v);
    });
    return updates;
  }

  insertIfAbsent(...values: T[]): T[] {
    const insertions: T[] = [];
    values.forEach((v) => {
      if (!v) return;
      const presentValue = this.get(this.idGetter(v));
      if (presentValue) return;
      const presentKey = this.firstIndex(v);
      if (this.array[presentKey] && this.key.key(this.array[presentKey]) === this.key.key(v)) return;
      this.insert(v);
      insertions.push(v);
    });
    return insertions;
  }

  deleteById(id: string, assertPresent = true): T | null {
    const value = this.get(id);
    if (!value) {
      if (assertPresent) throw new Error(`Value not found for ID: ${id}`);
      else return null;
    }
    return this.delete(value);
  }

  delete(value: T): T | null {
    const index = this.firstIndex(value);
    if (index < 0 || index >= this.array.length) return null;
    delete this.dict[this.idGetter(value)];
    return this.array.splice(index, 1)[0];
  }

  slice(start: number, end: number): KeyedDB<T> {
    const db = new KeyedDB(this.key, this.idGetter);
    db.array = this.array.slice(start, end);
    db.array.forEach((item) => db.dict[this.idGetter(item)] = item);
    return db;
  }

  clear(): void {
    this.array = [];
    this.dict = {};
  }

  get(id: string): T | undefined {
    return this.dict[id];
  }

  all(): T[] {
    return this.array;
  }

  update(id: string, update: (value: T) => void): number {
    const value = this.get(id);
    if (!value) return 0;
    const idx = this.firstIndex(value);
    if (idx < 0 || idx >= this.array.length) return 0;
    const oldKey = this.key.key(value);
    update(value);
    const newKey = this.key.key(value);
    if (newKey !== oldKey) {
      delete this.dict[id];
      this.array.splice(idx, 1);
      this._insertSingle(value);
      return 2;
    }
    return 1;
  }

  updateKey(value: T, update: (value: T) => void): number {
    return this.update(this.idGetter(value), update);
  }

  filter(predicate: (value: T, index: number) => boolean): KeyedDB<T> {
    const db = new KeyedDB(this.key, this.idGetter);
    db.array = this.array.filter((value, index) => {
      if (predicate(value, index)) {
        db.dict[this.idGetter(value)] = value;
        return true;
      }
    });
    return db;
  }

  paginatedByValue(
    value: T | null,
    limit: number,
    predicate: ((value: T) => boolean) | null,
    mode: "after" | "before" = "after"
  ): T[] {
    return this.paginated(
      value ? this.key.key(value) : null,
      limit,
      predicate,
      mode
    );
  }

  paginated(
    cursor: string | null,
    limit: number,
    predicate: ((value: T) => boolean) | null,
    mode: "after" | "before" = "after"
  ): T[] {
    let index = mode === "after" ? 0 : this.array.length;
    if (cursor !== null && typeof cursor !== "undefined") {
      index = BinarySearch.default(
        this.array,
        (v) => this.key.compare(cursor, this.key.key(v))
      );
      if (index < 0) index = 0;
      if (this.key.key(this.array[index]) === cursor)
        index += mode === "after" ? 1 : 0;
    }
    return this.filtered(index, limit, mode, predicate);
  }

  _insertSingle(value: T): void {
    if (!value) throw new Error('falsey value');
    const valueID = this.idGetter(value);
    if (this.get(valueID)) {
      throw new Error(`duplicate ID being inserted: ${valueID}`);
    }
    if (this.array.length > 0) {
      const index = this.firstIndex(value);
      if (index >= this.array.length) this.array.push(value);
      else if (index < 0) this.array.unshift(value);
      else if (this.key.key(value) !== this.key.key(this.array[index]))
        this.array.splice(index, 0, value);
      else throw new Error(`duplicate key: ${this.key.key(value)}, of inserting: ${valueID}, present: ${this.idGetter(this.array[index])}`);
    } else {
      this.array.push(value);
    }
    this.dict[valueID] = value;
  }

  filtered(
    start: number,
    count: number,
    mode: "after" | "before",
    predicate: ((value: T) => boolean) | null
  ): T[] {
    let arr: T[];
    if (mode === "after") {
      if (predicate) {
        arr = [];
        for (let item of this.array.slice(start)) {
          predicate(item) && arr.push(item);
          if (arr.length >= count) break;
        }
      } else arr = this.array.slice(start, start + count);
    } else if (mode === "before") {
      if (predicate) {
        arr = [];
        for (let i = start - 1; i >= 0; i--) {
          const item = this.array[i];
          predicate(item) && arr.unshift(item);
          if (arr.length >= count) break;
        }
      } else arr = this.array.slice(Math.max(start - count, 0), start);
    } else {
      throw new Error(`Invalid mode: ${mode}`);
    }
    return arr;
  }

  firstIndex(value: T): number {
    const valueKey = this.key.key(value);
    if (!this.array.length) return -1;
    const index = BinarySearch.default(
      this.array,
      (v) => this.key.compare(valueKey, this.key.key(v))
    );
    if (index < 0) return -1;
    return index;
  }
}

export default KeyedDB;
