'use strict';

const test = require('tape');
const callBound = require('../callBound');

test('callBound', (t) => {
  // static primitive
  t.equal(callBound('Array.length'), Array.length, "Array's 'length' property yields itself");
  t.equal(callBound('%Array.length%'), Array.length, "'%Array.length%' yields Array's length");

  // static non-function object
  t.equal(callBound('Array.prototype'), Array.prototype, "Array's 'prototype' yields itself");
  t.equal(callBound('%Array.prototype%'), Array.prototype, "'%Array.prototype%' yields Array's prototype");
  t.equal(callBound('Array.constructor'), Array.constructor, "Array's 'constructor' yields itself");
  t.equal(callBound('%Array.constructor%'), Array.constructor, "'%Array.constructor%' yields Array's constructor");

  // static function
  t.equal(callBound('Date.parse'), Date.parse, "Date's 'parse' method yields itself");
  t.equal(callBound('%Date.parse%'), Date.parse, "'%Date.parse%' yields Date's parse method");

  // prototype primitive
  t.equal(callBound('Error.prototype.message'), Error.prototype.message, "Error's 'message' property yields itself");
  t.equal(callBound('%Error.prototype.message%'), Error.prototype.message, "'%Error.prototype.message%' yields Error's message property");

  // prototype function
  t.notEqual(callBound('Object.prototype.toString'), Object.prototype.toString, "Object's 'toString' method does not yield itself");
  t.notEqual(callBound('%Object.prototype.toString%'), Object.prototype.toString, "'%Object.prototype.toString%' does not yield Object's toString method");
  t.equal(callBound('Object.prototype.toString')(true), Object.prototype.toString.call(true), "call-bound Object.prototype.toString calls into the original");
  t.equal(callBound('%Object.prototype.toString%')(true), Object.prototype.toString.call(true), "call-bound %Object.prototype.toString% calls into the original");

  t.throws(
    () => callBound('does not exist'),
    SyntaxError,
    'nonexistent intrinsic throws'
  );
  t.throws(
    () => callBound('does not exist', true),
    SyntaxError,
    'allowMissing arg still throws for unknown intrinsic'
  );

  t.test('real but absent intrinsic', { skip: typeof WeakRef !== 'undefined' }, (st) => {
    st.throws(
      () => callBound('WeakRef'),
      TypeError,
      'real but absent intrinsic throws'
    );
    st.equal(callBound('WeakRef', true), undefined, "allowMissing arg avoids exception");
    st.end();
  });

  t.end();
});
