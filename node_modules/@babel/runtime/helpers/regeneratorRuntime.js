/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

const { defineProperty } = Object;
const { hasOwnProperty } = Object.prototype;
const { asyncIterator: ASYNC_ITERATOR, toStringTag: TO_STRING_TAG } = Symbol;

const define = (obj, key, value) => defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });

const wrap = (fn, handler, context) => {
  const invoke = async (method, arg) => {
    const iterator = fn[method];
    if (!iterator) throw new Error(`${method} method not found`);
    const result = await iterator.call(fn, arg);
    if (result.done) return result.value;
    return handler.resolve(result.value);
  };
  return new Proxy(fn, {
    _invoke: {
      value: invoke
    }
  });
};

const tryCatch = (fn, thisArg, arg) => {
  try {
    return { type: 'normal', arg: fn.call(thisArg, arg) };
  } catch (error) {
    return { type: 'throw', arg: error };
  }
};

const asyncGenerator = Symbol('asyncGenerator');
const asyncIterator = {
  [ASYNC_ITERATOR]: async function* () {
    let generator = this;
    while (true) {
      const method = generator._invoke;
      if (!method) break;
      const result = await method.call(generator);
      if (result.done) break;
      yield result.value;
    }
  }
};

const makeInvokeMethod = (generatorFn, handler, context) => {
  let state = 'suspendedStart';
  const delegate = {
    iterator: undefined,
    resultName: undefined,
    nextLoc: undefined
  };
  const generator = new generatorFn.constructor(function* () {
    yield* asyncIterator;
  });
  define(generator, asyncIterator);
  const generatorPrototype = generator.constructor.prototype;
  const methodNames = Object.getOwnPropertyNames(generatorPrototype);
  methodNames.forEach(method => {
    if (method === 'constructor' || method === asyncGenerator) return;
    define(generator, method, function* (...args) {
      return yield* handler.call(this, method, args);
    });
  });
  return async function* (...args) {
    if (state === 'suspendedStart') {
      if (args.length) {
        delegate.iterator = args[0][asyncIterator];
        if (!delegate.iterator) throw new TypeError('iterator is not async');
        delegate.resultName = 'result';
        delegate.nextLoc = 'next';
      }
    }
    while (true) {
      const method = this[asyncGenerator];
      if (!method) throw new TypeError('Generator is already finished');
      const result = tryCatch(method, generator, args);
      if (result.type === 'throw') {
        state = 'completed';
        if (delegate.iterator) {
          delegate.iterator = undefined;
          return;
        }
        throw result.arg;
      }
      const value = result.arg;
      const done = value === undefined;
      if (state === 'suspendedYield') {
        this[delegate.resultName] = value;
        state = 'executing';
        if (!done) {
          const next = this[delegate.nextLoc];
          if (typeof next === 'function') {
            const result = tryCatch(next, this, []);
            if (result.type === 'throw') {
              state = 'completed';
              if (delegate.iterator) {
                delegate.iterator = undefined;
                return;
              }
              throw result.arg;
            }
            value = result.arg;
            done = value === undefined;
          }
        }
      }
      if (done) {
        state = 'completed';
        if (delegate.iterator) {
          delegate.iterator = undefined;
          return;
        }
      } else {
        state = 'suspendedYield';
      }
      if (delegate.iterator) {
        const result = tryCatch(delegate.iterator[delegate.nextLoc], delegate.iterator, []);
        if (result.type === 'throw') {
          state = 'completed';
          if (delegate.iterator) {
            delegate.iterator = undefined;
            return;
          }
          throw result.arg;
        }
        value = result.arg;
        done = value === undefined;
        if (done) {
          delegate.iterator = undefined;
        }
      }
      if (state === 'executing') {
        const result = tryCatch(this[method], this, [value]);
        if (result.type === 'throw') {
          state = 'completed';
          if (delegate.iterator) {
            delegate.iterator = undefined;
            return;
         
