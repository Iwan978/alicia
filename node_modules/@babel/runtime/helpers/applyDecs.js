import {
  isCallable,
  isObject,
  isSymbol,
  isUndefined,
  getOwnPropertyDescriptor,
  defineProperty,
  getPrototypeOf,
  setPrototypeOf,
  getOwnPropertyNames,
  getOwnPropertySymbols,
  createNonEnumerableProperty,
  getMetadata,
  setMetadata,
  hasMetadata,
  metadataStorageKey,
  assertNotFinished,
  assertCallable,
  assertValidReturnValue,
  getInit,
} from './utils';

type MemberDecorator = (
  target: object,
  propertyKey: string | symbol,
  descriptor?: PropertyDescriptor,
  options?: Record<string, any>
) => PropertyDescriptor | void;

type ClassDecorator = <TFunction extends Function>(
  constructor: TFunction,
  options?: Record<string, any>
) => TFunction | void;

type MetadataKey = symbol;

type MetadataMap = Map<MetadataKey, any>;

type Metadata = {
  [key: string]: MetadataMap;
};

type MetadataProperty = {
  kind: 'field' | 'get' | 'set' | 'method' | 'accessor';
  name: string | symbol;
  isStatic: boolean;
  isPrivate: boolean;
  addInitializer?: (initializer: Function) => void;
};

type MetadataPropertyWithMetadata = MetadataProperty & {
  metadata: MetadataMap;
};

type MemberDecoratorContext = {
  v: boolean;
};

type MemberDecoratorArgs = [
  memberDecorator: MemberDecorator,
  propertyKey: string | symbol,
  propertyDescriptor?: PropertyDescriptor,
  target: object,
  metadataKey: MetadataKey,
  metadata: Metadata,
  decoratorArguments: any[],
  isMethod: boolean,
  isAccessor: boolean,
  isStatic: boolean
];

function createMetadataMethodsForProperty(
  metadataKey: MetadataKey,
  metadata: Metadata,
  metadataProperty: MetadataPropertyWithMetadata
): {
  getMetadata: (key: string | symbol) => any;
  setMetadata: (key: string | symbol, value: any) => void;
} {
  const getMetadata = (key: string | symbol) => {
    assertNotFinished(metadataProperty, 'getMetadata');
    assertMetadataKey(key);
    const propertyMetadata = metadata[metadataKey];
    if (propertyMetadata) {
      const value =
        metadataProperty.kind === 'field'
          ? propertyMetadata.get(metadataProperty.name)
          : propertyMetadata.get(key);
      if (!isUndefined(value)) {
        return value;
      }
    }
  };

  const setMetadata = (key: string | symbol, value: any) => {
    assertNotFinished(metadataProperty, 'setMetadata');
    assertMetadataKey(key);
    let propertyMetadata = metadata[metadataKey];
    if (!propertyMetadata) {
      propertyMetadata = metadata[metadataKey] = new Map();
    }
    if (metadataProperty.kind === 'field') {
      propertyMetadata.set(metadataProperty.name, value);
    } else {
      propertyMetadata.set(key, value);
    }
  };

  return {
    getMetadata,
    setMetadata,
  };
}

function convertMetadataMapToFinal(
  metadata: Metadata,
  target: object,
  metadataKey: MetadataKey
): void {
  const propertySymbols = getOwnPropertySymbols(target);
  if (propertySymbols.length > 0) {
    for (const propertySymbol of propertySymbols) {
      const propertyMetadata = metadata[metadataKey];
      if (propertyMetadata) {
        const propertyValue = target[propertySymbol];
        const propertyMetadataValue = propertyMetadata.get(propertySymbol);
        if (propertyMetadataValue) {
          const publicMetadataValue =
            propertyMetadataValue['public'];
          if (publicMetadataValue) {
            const prototype = getPrototypeOf(target);
            if (prototype) {
              const prototypePublicMetadataValue =
                getMetadata(propertySymbol, prototype);
              if (prototypePublicMetadataValue) {
                setPrototypeOf(
                  publicMetadataValue,
                  prototypePublicMetadataValue
                );
              }
            }
            const privateMetadataValues =
              propertyMetadataValue['private'];
            if (privateMetadataValues) {
              const mergedPrivateMetadataValues = [
                ...(propertyMetadataValue['private'] as any),
                ...(getMetadata(
                  'private',
                  target
                ) as any),
              ];
              propertyMetadata.set(
                'private',
                new Map(
                  mergedPrivateMetadataValues.map((value) => [
                    value[0],
                    value[1],
                  ])
                )
              );
            }
          }
          setMetadata(propertySymbol, propertyValue);
        }
      }
    }
    createNonEnumerableProperty(
      target,
      metadataKey,
      metadata[metadataKey]
    );
  }
}

function createAddInitializerMethod(
  initializers: Function[],
  context: MemberDecoratorContext
): (initializer: Function) => void {
  return (initializer: Function) => {
    assertNotFinished(context, 'addInitializer');
    initializers.push(initializer);
  };
}

function memberDec(
  memberDecorator: MemberDecorator,
  propertyKey: string | symbol,
  propertyDescriptor?: PropertyDescriptor,
  target: object = undefined,
  metadataKey: MetadataKey = undefined,
  metadata: Metadata = undefined,
  decoratorArguments: any[] = [],
  isMethod: boolean = false,
  isAccessor: boolean = false,
  isStatic: boolean = false
): PropertyDescriptor | void {
  const metadataProperty: MetadataPropertyWithMetadata = {
    kind: isAccessor
      ? propertyKey === 'get'
        ? 'get'
        : 'set'
      : isMethod
      ? 'method'
      : 'field',
    name: propertyKey,
    isStatic,
    isPrivate: !!metadataKey,
    metadata: new Map(),
  };

  if (
    !isUndefined(metadata) &&
    !isUndefined(metadataKey) &&
    !isUndefined(metadataProperty)
  ) {
    const { getMetadata, setMetadata } = createMetadataMethodsForProperty(
      metadataKey,
      metadata,
      metadataProperty
    );

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.value)
    ) {
      const propertyValue = propertyDescriptor.value;
      setMetadata('value', propertyValue);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.get)
    ) {
      const propertyGet = propertyDescriptor.get;
      setMetadata('get', propertyGet);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.set)
    ) {
      const propertySet = propertyDescriptor.set;
      setMetadata('set', propertySet);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.initializer)
    ) {
      const propertyInitializer = propertyDescriptor.initializer;
      setMetadata('initializer', propertyInitializer);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.init)
    ) {
      const propertyInit = propertyDescriptor.init;
      setMetadata('init', propertyInit);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.configurable)
    ) {
      const propertyConfigurable = propertyDescriptor.configurable;
      setMetadata('configurable', propertyConfigurable);
    }

    if (
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.enumerable)
    ) {
      const propertyEnumerable = propertyDescriptor.enumerable;
      setMetadata('enumerable', propertyEnumerable);
    }
  }

  const context: MemberDecoratorContext = {
    v: false,
  };

  const result =
    memberDecorator(target, propertyKey, propertyDescriptor, context);

  if (
    !isUndefined(result) &&
    (!isMethod || !isUndefined(result.value)) &&
    (!isAccessor ||
      (!isUndefined(result.get) && !isUndefined(result.set)))
  ) {
    assertValidReturnValue(
      isMethod || isAccessor ? 1 : 0,
      result
    );

    if (
      !isUndefined(result.value) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.value)
    ) {
      propertyDescriptor.value = result.value;
    }

    if (
      !isUndefined(result.get) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.get)
    ) {
      propertyDescriptor.get = result.get;
    }

    if (
      !isUndefined(result.set) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.set)
    ) {
      propertyDescriptor.set = result.set;
    }

    if (
      !isUndefined(result.initializer) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.initializer)
    ) {
      propertyDescriptor.initializer = result.initializer;
    }

    if (
      !isUndefined(result.init) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.init)
    ) {
      propertyDescriptor.init = result.init;
    }

    if (
      !isUndefined(result.configurable) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.configurable)
    ) {
      propertyDescriptor.configurable = result.configurable;
    }

    if (
      !isUndefined(result.enumerable) &&
      !isUndefined(propertyDescriptor) &&
      !isUndefined(propertyDescriptor.enumerable)
    ) {
      propertyDescriptor.enumerable = result.enumerable;
    }
  }

  if (
    !isUndefined(result) &&
    (!isMethod || !isUndefined(result.value)) &&
    (!isAccessor ||
      (!isUndefined(result.get) && !isUndefined(result.set)))
  ) {
    return result;
  }
}

function applyDecs(
  constructor: Function,
  decorators: ClassDecorator[],
  memberDecorators: MemberDecorator[],
  metadataKey: MetadataKey,
  metadata: Metadata
): Function[] {
  const memberDecoratorContexts: MemberDecoratorContext[] = [];
  const memberDecoratorsByKey: Map<
    MetadataKey,
    MemberDecorator[]
  > = new Map();

  for (const memberDecorator of memberDecorators) {
    const memberDecoratorKey =
      typeof memberDecorator === 'symbol'
        ? memberDecorator
        : metadataKey;
    const memberDecoratorsForKey =
      memberDecoratorsByKey.get(memberDecoratorKey) || [];
    memberDecoratorsForKey.push(memberDecorator);
    memberDecoratorsByKey.set(memberDecoratorKey, memberDecoratorsForKey);
  }

  const initializers: Function[] = [];

  const applyMemberDecorator = (
    target: object,
    propertyKey: string | symbol,
    descriptor?: PropertyDescriptor,
    options?: Record<string, any>
  ): PropertyDescriptor => {
    const memberDecoratorArgs: MemberDecoratorArgs = [
      memberDecorator,
      propertyKey,
      descriptor,
      target,
      metadataKey,
      metadata,
      [],
      false,
      false,
      false,
    ];

    if (
      hasMetadata(metadataKey, target) &&
      !isUndefined(propertyKey) &&
      !isUndefined(target)
    ) {
      const propertyMetadata = getMetadata(metadataKey, target);
      if (propertyMetadata) {
        memberDecoratorArgs[6] = Array.from(propertyMetadata.values());
      }
    }

    const memberDecoratorContext: MemberDecoratorContext = {
      v: false,
    };

    memberDecoratorArgs[7] = memberDecoratorContext;

    const memberDecoratorResult =
      memberDecorator.apply(null, memberDecoratorArgs);

    if (
      !isUndefined(memberDecoratorResult) &&
      (!isUndefined(memberDecoratorResult.value) ||
        (!isUndefined(memberDecoratorResult.get) &&
          !isUndefined(memberDecoratorResult.set)))
    ) {
      assertValidReturnValue(1, memberDecoratorResult);
    }

    memberDecoratorContexts.push(memberDecoratorContext);

    return memberDecoratorResult || descriptor;
  };

  const applyMemberDecorators = (
    target: object,
    propertyKey: string | symbol,
    descriptor?: PropertyDescriptor
  ): PropertyDescriptor => {
    if (
      !isUndefined(propertyKey) &&
      !isUndefined(target) &&
      hasMetadata(metadataKey, target)
    ) {
      const memberDecoratorsForKey =
        memberDecoratorsByKey.get(metadataKey);
      if (memberDecoratorsForKey) {
        for (const memberDecorator of memberDecoratorsForKey) {
          descriptor = applyMemberDecorator(
            target,
            propertyKey,
            descriptor,
            memberDecorator
          );
        }
      }
    }

    return descriptor;
  };

  const apply
