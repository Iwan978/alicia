import * as _typeof from "./typeof";
import setPrototypeOf from "./setPrototypeOf";
import inherits from "./inherits";

type Groups = { [key: string]: number | string[] };

function _wrapRegExp(e: RegExp, r?: Groups) {
  _wrapRegExp = function _wrapRegExp(e: RegExp, r?: Groups) {
    return new BabelRegExp(e, void 0, r);
  };
  const ePrototype = RegExp.prototype,
    groupsMap = new WeakMap<RegExp, Groups>();
  function BabelRegExp(e: RegExp, t?: "g" | "gi" | "gim" | "gmi", p?: Groups) {
    const o = new RegExp(e, t);
    groupsMap.set(o, p || groupsMap.get(e) || {});
    return setPrototypeOf(o, BabelRegExp.prototype);
  }
  function buildGroups(e: RegExpExecArray, t: RegExp): Groups {
    const p = groupsMap.get(t);
    return Object.keys(p).reduce((r, t) => {
      const o = p[t];
      if (typeof o === "number") r[t] = e[o];
      else {
        for (let i = 0; void 0 === e[o[i]] && i + 1 < o.length; i++);
        r[t] = e[o[i]];
      }
      return r;
    }, Object.create(null));
  }
  return (
    inherits(BabelRegExp, RegExp),
    (BabelRegExp.prototype as RegExp).exec = function (this: RegExp, r: string) {
      const t = ePrototype.exec.call(this, r);
      if (t) {
        const p = this as BabelRegExp;
        t.groups = buildGroups(t, p);
        const o = t.indices;
        o && (o.groups = buildGroups(o, p));
      }
      return t;
    },
    (BabelRegExp.prototype as RegExp).replace = function (
      this: RegExp,
      t: string | ((substring: string, ...args: any[]) => string),
      p: ((substring: string, ...args: any[]) => string) | { [key: string]: any }
    ) {
      if (typeof t === "string") {
        const o = groupsMap.get(this as BabelRegExp);
        return ePrototype.replace.call(
          this,
          t,
          (e: string) =>
            p.replace(
              /\$<([^>]+)>/g,
              (_, r) =>
                "$" +
                (Array.isArray(o[r])
                  ? o[r].join("$")
                  : typeof o[r] === "string"
                  ? o[r]
                  : "")
            )
        );
      }
      if (typeof p === "function") {
        const o = this as BabelRegExp;
        return ePrototype.replace.call(
          this,
          t,
          (...e: any[]) =>
            "object" !== _typeof(e[e.length - 1]) &&
              e.push(buildGroups(e, o)),
          p
        );
      }
      return ePrototype.replace.call(this, t, p);
    },
    _wrapRegExp.apply(this, arguments)
  );
}

if (
  !RegExp.prototype.hasOwnProperty("exec") ||
  !RegExp.prototype.hasOwnProperty(Symbol.replace)
) {
  throw new Error("The RegExp prototype has been modified");
}

if (
  !BabelRegExp.prototype.hasOwnProperty("exec") ||
  !BabelRegExp.prototype.hasOwnProperty(Symbol.replace)
) {
  throw new Error("The BabelRegExp prototype has been modified");
}
