import _typeof from "./typeof.js";
import checkInRHS from "./checkInRHS.js";

function isCallable(fn: any): fn is Function {
  return typeof fn === "function";
}

function isValidReturnValue(fn: any, type: number): void {
  if (type === 1) {
    if (typeof fn !== "object" || fn === null) {
      throw new TypeError(`accessor decorators must return an object with get, set, or init properties or void 0`);
    }
    if (!isCallable(fn.get)) {
      throw new TypeError(`accessor.get must be a function`);
    }
    if (!isCallable(fn.set)) {
      throw new TypeError(`accessor.set must be a function`);
    }
    if (!isCallable(fn.init)) {
      throw new TypeError(`accessor.init must be a function`);
    }
  } else if (type !== "function") {
    throw new TypeError(`${0 === type ? "field" : 5 === type ? "class" : "method"} decorators must return a function or void 0`);
  }
}

function definePropertyDescriptor(options: {
  get?: Function;
  set?: Function;
  value?: any;
}): PropertyDescriptor {
  const descriptor: PropertyDescriptor = {};
  if (options.get) {
    descriptor.get = options.get;
  }
  if (options.set) {
    descriptor.set = options.set;
  }
  if (options.value) {
    descriptor.value = options.value;
  }
  return descriptor;
}

function applySingleDecorator(
  target: any,
  propertyKey: string | symbol,
  decorator: Function,
  decoratorArgs: any[]
): void {
  const result = decorator(target, {
    kind: "field",
    name: propertyKey.toString(),
    static: false,
    private: false,
    metadata: undefined,
    addInitializer: (initializer: Function) => {
      target.initializers = target.initializers || [];
      target.initializers.push(initializer);
    },
  }, ...decoratorArgs);

  isValidReturnValue(result, 1);

  const descriptor = definePropertyDescriptor(result);
  Object.defineProperty(target, propertyKey, descriptor);
}

function applyDecorators(
  target: any,
  propertyKey: string | symbol,
  decorators: Function[],
  decoratorArgs: any[]
): void {
  for (const decorator of decorators) {
    applySingleDecorator(target, propertyKey, decorator, decoratorArgs);
  }
}

function _bindPropCall(e: any, t: string) {
  return function (r: any, a: any) {
    return e[t].call(r, a);
  };
}

function createAddInitializerMethod(e: any[], p: { v: boolean }) {
  return function (r: Function) {
    if (p.v) throw new Error("attempted to call addInitializer after decoration was finished");
    isCallable(r);
    e.push(r);
  };
}

function memberDec(
  e: any,
  t: any,
  r: string,
  a: PropertyDescriptor,
  n: number,
  i: number,
  o: boolean,
  s: boolean,
  l: any,
  c: Function,
  u: any
) {
  function assertInstanceIfPrivate(e: Function) {
    return function (t: any, r: any) {
      if (!c(t)) throw new TypeError("Attempted to access private element on non-instance");
      return e(t, r);
    };
  }

  const p = {
    v: !1
  };

  const property: PropertyDescriptor = {
    kind: ["field", "accessor", "method", "getter", "setter", "field"][i],
    name: s ? "#" + r : r,
    "static": o,
    "private": s,
    metadata: u,
    addInitializer: createAddInitializerMethod([], p)
  };

  if (s || n !== 2 && n !== 1) {
    if (n === 2) {
      const f = assertInstanceIfPrivate(function () {
        return a.value;
      });
      property.get = f;
      s && (property.get = assertInstanceIfPrivate(property.get));
    } else {
      let f: any;
      const h = n === 0 || n === 1;
      (h || n === 3) && (f = _bindPropCall(a, "get"), s && (f = assertInstanceIfPrivate(f))), (h || n === 4) && (property.set = _bindPropCall(a, "set"), s && (property.set = assertInstanceIfPrivate(property.set)));
    }
  } else {
    const f = function f(e: any) {
      return e[r];
    };
    property.get = f;
  }

  const has = s ? c.bind(null) : function (e: any) {
    return r in e;
  };

  property.access = {
    has: has
  };

  try {
    return e.call(t, l, property);
  } finally {
    p.v = !0;
  }
}

function applyMemberDecs(
  e: any,
  t: Function[],
  r: any[],
  a: any
): any[] {
  const s: any[] = [];
  const l: Map<string | symbol, number> = new Map();
  const c: Map<string | symbol, boolean> = new Map();

  function pushInitializers(e: any[]) {
    e && s.push(function (t: any) {
      for (let r = 0; r < e.length; r++) {
        e[r].call(t);
      }
      return t;
    });
  }

  for (let u = 0; u < t.length; u++) {
    const f = t[u];
    if (Array.isArray(f)) {
      const d = f[1];
      const p = f[2];
      const v = f.length > 3;
      const h = 16 & d;
      const m = !!(8 & d);
      const b = r;
      if (d &= 7) {
        const y = m ? l : c;
        const g = y.get(p) || 0;
        if (!0 === g || 3 === g && 4 !== d || 4 === g && 3 !== d) {
          throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + p);
        }
        y.set(p, !(!g && d > 2) || d);
      }
      applyMemberDec(s, e, f, h, p, d, m, v, b, a);
    }
  }

  pushInitializers(r);
  pushInitializers(c.keys());

  return s;
}

function applyClassDecs(
  e: any,
  t: Function[],
  r: any,
  a: any
): [any, Function] {
  if (t.length) {
    for (let n = [], i = e, o = e.name, s = r ? 2 : 1, l = t.length - 1; l >= 0; l -= s) {
      const u = {
        v: !1
      };

      try {
        const f = t[l].call(r ? t[l - 1] : void 0, i, {
          kind: "class",
          name: o,
          addInitializer: (initializer: Function) => {
            n.push(initializer);
          },
          metadata: a
        });

        isValidReturnValue(f, 5);

        i = f;
      } finally {
        u.v = !0;
      }
    }

    return [defineMetadata(i, a), function () {
      for (let e = 0; e < n.length; e++) {
        n[e].call(i);
      }
    }];
  }
}

function defineMetadata(e: any, t: any) {
  return Object.defineProperty(e, Symbol.metadata || Symbol["for"]("Symbol.metadata"), {
    configurable: !0,
    enumerable: !0,
    value: t
  });
}

export default function applyDecs2305(
  e: any,
  t: Function[],
  r: any[],
  a: any,
  n: any,
  i: any
): { e: any; c: any; } {
  if (arguments.length >= 6) {
    const o = i[Symbol.metadata || Symbol["for"]("Symbol.metadata")];
    const s = Object.create(void 0 === o ? null : o);
    const l = applyMemberDecs(e, t, n, s);
    return r.length || defineMetadata(e, s), {
      e: l,
      get c() {
        return applyClassDecs(e, r, a, s);
      }
    };
  }
}
